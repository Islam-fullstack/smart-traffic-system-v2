у меня появляется ошибки когда запускаю этот файл(visualization.py):

import pygame
import matplotlib.pyplot as plt
import numpy as np
from moviepy.editor import VideoClip
from moviepy.video.io.bindings import mplfig_to_npimage
import argparse
import os
from datetime import datetime
from traffic_model import Intersection, TrafficLight, Lane  # Добавлены недостающие импорты

class IntersectionVisualizer:
    COLORS = {
        'road': (100, 100, 100),
        'lane_marking': (200, 200, 200),
        'car': (0, 0, 255),
        'truck': (255, 165, 0),
        'bus': (255, 0, 0),
        'motorcycle': (0, 255, 0),
        'traffic_light': {
            'red': (255, 0, 0),
            'yellow': (255, 255, 0),
            'green': (0, 255, 0)
        }
    }

    def __init__(self, window_size=(800, 600), intersection=None, traffic_light=None,
                 scale=10, fps=30, background_color=(255, 255, 255)):
        self.window_size = window_size
        self.intersection = intersection or Intersection([], TrafficLight())  # Значение по умолчанию
        self.traffic_light = traffic_light or self.intersection.traffic_light
        self.scale = scale
        self.fps = fps
        self.bg_color = background_color
        self.screen = None
        self.clock = None
        self.font = None

    def initialize_display(self):
        try:
            pygame.init()
            self.screen = pygame.display.set_mode(self.window_size)
            pygame.display.set_caption("Smart Traffic Visualization")
            self.clock = pygame.time.Clock()
            self.font = pygame.font.SysFont('Arial', 18)
        except pygame.error as e:
            print(f"Error initializing Pygame: {e}")
            raise

    def draw_intersection(self):
        # Draw roads
        road_width = 6 * self.scale
        pygame.draw.rect(self.screen, self.COLORS['road'], 
                        (self.window_size[0]//2 - road_width//2, 0, road_width, self.window_size[1]))
        pygame.draw.rect(self.screen, self.COLORS['road'], 
                        (0, self.window_size[1]//2 - road_width//2, self.window_size[0], road_width))

        # Draw lane markings
        marking_length = 2 * self.scale
        for i in range(0, self.window_size[1], 5*self.scale):
            pygame.draw.line(self.screen, self.COLORS['lane_marking'],
                            (self.window_size[0]//2 - 3*self.scale, i),
                            (self.window_size[0]//2 - 3*self.scale, i + marking_length), 2)
            pygame.draw.line(self.screen, self.COLORS['lane_marking'],
                            (self.window_size[0]//2 + 3*self.scale, i),
                            (self.window_size[0]//2 + 3*self.scale, i + marking_length), 2)

    def draw_vehicles(self, vehicles):
        for vehicle in vehicles:
            color = self.COLORS.get(vehicle.type, (0,0,0))
            length = vehicle.length * self.scale
            width = 2 * self.scale
            x, y = self._convert_coords(vehicle.position, vehicle.direction)
            pygame.draw.rect(self.screen, color, (x - width//2, y - length//2, width, length))

    def draw_traffic_lights(self):
        directions = ['north', 'south', 'east', 'west']
        light_radius = self.scale // 2
        for i, direction in enumerate(directions):
            state = self.traffic_light.get_state().get(direction, 'red')
            x, y = self._get_traffic_light_pos(direction)
            pygame.draw.circle(self.screen, self.COLORS['traffic_light'][state], (x, y), light_radius)

    def _convert_coords(self, position, direction):
        base_x = self.window_size[0] // 2
        base_y = self.window_size[1] // 2
        offset = position * self.scale
        
        if direction == 'north':
            return (base_x - 3*self.scale, base_y - offset)
        elif direction == 'south':
            return (base_x + 3*self.scale, base_y + offset)
        elif direction == 'east':
            return (base_x + offset, base_y + 3*self.scale)
        elif direction == 'west':
            return (base_x - offset, base_y - 3*self.scale)

    def _get_traffic_light_pos(self, direction):
        margin = 5 * self.scale
        if direction == 'north':
            return (self.window_size[0]//2 - 3*self.scale, margin)
        elif direction == 'south':
            return (self.window_size[0]//2 + 3*self.scale, self.window_size[1] - margin)
        elif direction == 'east':
            return (self.window_size[1] - margin, self.window_size[1]//2 + 3*self.scale)
        elif direction == 'west':
            return (margin, self.window_size[1]//2 - 3*self.scale)

    def draw_metrics(self, metrics):
        y_offset = 10
        for key, value in metrics.items():
            text = self.font.render(f"{key}: {value:.2f}", True, (0,0,0))
            self.screen.blit(text, (10, y_offset))
            y_offset += 25

    def update(self, simulation_state):
        self.screen.fill(self.bg_color)
        self.draw_intersection()
        self.draw_vehicles(simulation_state['vehicles'])
        self.draw_traffic_lights()
        self.draw_metrics(simulation_state['metrics'])
        pygame.display.flip()
        self.clock.tick(self.fps)

    def run_animation(self, simulation):
        self.initialize_display()
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            state = simulation.get_current_state()
            self.update(state)
            
        pygame.quit()

    def save_animation(self, output_file, simulation):
        fig, ax = plt.subplots(figsize=(self.window_size[0]/100, self.window_size[1]/100))
        
        def make_frame(t):
            simulation.step()
            state = simulation.get_current_state()
            self.update(state)
            return pygame.surfarray.array3d(self.screen)
        
        animation = VideoClip(make_frame, duration=simulation.total_time)
        animation.write_videofile(output_file, fps=self.fps)

class ComparisonVisualizer:
    def __init__(self, window_size=(1200, 600), traditional_sim=None, smart_sim=None,  # Изменены параметры
                 scale=10, fps=30):
        self.window_size = window_size
        self.traditional_vis = IntersectionVisualizer(
            (window_size[0]//2, window_size[1]),
            traditional_sim.intersection if traditional_sim else None,
            scale=scale,
            fps=fps
        )
        self.smart_vis = IntersectionVisualizer(
            (window_size[0]//2, window_size[1]),
            smart_sim.intersection if smart_sim else None,
            scale=scale,
            fps=fps
        )
        self.screen = None
        self.clock = None

    def initialize_display(self):
        pygame.init()
        self.screen = pygame.display.set_mode(self.window_size)
        pygame.display.set_caption("Controller Comparison")
        self.clock = pygame.time.Clock()

    def draw_split_view(self, traditional_state, smart_state):
        self.screen.fill((255,255,255))
        
        # Draw traditional visualization
        trad_surface = pygame.Surface((self.window_size[0]//2, self.window_size[1]))
        self.traditional_vis.screen = trad_surface
        self.traditional_vis.update(traditional_state)
        self.screen.blit(trad_surface, (0,0))
        
        # Draw smart visualization
        smart_surface = pygame.Surface((self.window_size[0]//2, self.window_size[1]))
        self.smart_vis.screen = smart_surface
        self.smart_vis.update(smart_state)
        self.screen.blit(smart_surface, (self.window_size[0]//2, 0))
        
        pygame.display.flip()
        self.clock.tick(self.traditional_vis.fps)

    def run_comparison_animation(self, traditional_sim, smart_sim):
        self.initialize_display()
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            trad_state = traditional_sim.get_current_state()
            smart_state = smart_sim.get_current_state()
            self.draw_split_view(trad_state, smart_state)
            
        pygame.quit()

class MetricsPlotter:
    def __init__(self, traditional_data, smart_data, output_dir):
        self.trad_data = traditional_data
        self.smart_data = smart_data
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def plot_waiting_time(self):
        plt.figure()
        plt.plot(self.trad_data['waiting_time'], label='Traditional')
        plt.plot(self.smart_data['waiting_time'], label='Smart')
        plt.title('Average Waiting Time Comparison')
        plt.xlabel('Time (s)')
        plt.ylabel('Seconds')
        plt.legend()
        plt.savefig(os.path.join(self.output_dir, 'waiting_time.png'))
        plt.close()

    def plot_throughput(self):
        plt.figure()
        plt.bar(['Traditional', 'Smart'], 
                [self.trad_data['throughput'], self.smart_data['throughput']])
        plt.title('Throughput Comparison')
        plt.ylabel('Vehicles per Hour')
        plt.savefig(os.path.join(self.output_dir, 'throughput.png'))
        plt.close()

    def save_all_plots(self):
        self.plot_waiting_time()
        self.plot_throughput()
        plt.close('all')

def main():
    parser = argparse.ArgumentParser(description='Traffic Visualization System')
    parser.add_argument('--mode', default='single', choices=['single', 'comparison'])
    parser.add_argument('--window-size', default='800,600')
    parser.add_argument('--fps', type=int, default=30)
    parser.add_argument('--output-dir', default='results')
    parser.add_argument('--save-animation', action='store_true')
    parser.add_argument('--scale', type=int, default=10)
    parser.add_argument('--interactive', action='store_true')
    args = parser.parse_args()

    # Инициализация тестовых объектов
    lanes = [
        Lane(lane_id=1, direction='north', length=100, max_speed=15.0),
        Lane(lane_id=2, direction='south', length=100, max_speed=15.0)
    ]
    traffic_light = TrafficLight()
    intersection = Intersection(lanes=lanes, traffic_light=traffic_light)

    visualizer = IntersectionVisualizer(
        window_size=tuple(map(int, args.window_size.split(','))),
        intersection=intersection,
        scale=args.scale,
        fps=args.fps
    )

    simulation = None

    if args.mode == 'single':
        from simulation_manager import SimulationManager
        from traditional_controller import TraditionalController, create_default_phases
        from smart_controller import SmartController
        
        traditional_controller = TraditionalController(
            phases=create_default_phases(),
            cycle_times={'day': 90},
            current_mode='day'
        )
        smart_controller = SmartController(
            directions=['north', 'south'],
            algorithm='fuzzy'
        )
        
        simulation = SimulationManager(
            traditional_controller=traditional_controller,
            smart_controller=smart_controller,
            simulation_time=60
        )
        visualizer.run_animation(simulation)
    
    if args.save_animation:
        if simulation is not None:
            visualizer.save_animation(os.path.join(args.output_dir, 'animation.mp4'), simulation)
        else:
            print("Error: Simulation not initialized. Cannot save animation.")

if __name__ == "__main__":
    main()